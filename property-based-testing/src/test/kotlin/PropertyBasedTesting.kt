
import io.kotest.core.spec.style.StringSpec
import io.kotest.property.Arb
import io.kotest.property.Exhaustive
import io.kotest.property.arbitrary.arbitrary
import io.kotest.property.arbitrary.email
import io.kotest.property.arbitrary.enum
import io.kotest.property.arbitrary.int
import io.kotest.property.arbitrary.ipAddressV4
import io.kotest.property.arbitrary.localDate
import io.kotest.property.arbitrary.orNull
import io.kotest.property.arbitrary.string
import io.kotest.property.arbitrary.stringPattern
import io.kotest.property.arbs.fooddrink.iceCreamFlavors
import io.kotest.property.arbs.geo.country
import io.kotest.property.arbs.name
import io.kotest.property.exhaustive.ints
import io.kotest.property.forAll

// https://kotest.io/docs/proptest/property-based-testing.html

// Instead of writing example-based tests, with property testing,
// hundreds or thousands of values are fed into the same test,
// and the values are (usually) randomly generated by your property test framework

class PropertyExample : StringSpec({
    "test with string and int" {
        // TODO convert to checkAll
        forAll<String, Int> { a, b -> assertSomething(a, b) }
    }
    "test with iterations" {
        forAll<String, Int>(5) { a, b -> assertSomething(a, b) }
    }
    "test with string pattern" {
        forAll(Arb.stringPattern("\\d{3}[abc]{1,2}")) { a -> assertSomething(a) }
    }
    "test with string orNull(nullProbability)" {
        // TODO add iterations
        forAll(Arb.string(3, 6).orNull(0.3)) { a -> assertSomething(a) }
    }
    "test with arbitrary ints" {
        forAll(Arb.int(1, 10)) { a -> assertSomething(a) }
    }
    "test with exhaustive ints" {
        forAll(Exhaustive.ints(1..10)) { a -> assertSomething(a) }
    }
    "test with arbitrary builder" {
        // TODO use iterations / it.random with a list
        forAll(arbitrary { "hola" }) { a -> assertSomething(a) }
    }
    "test with generator operations" {
        // TODO add filter, map and merge
        forAll(Exhaustive.ints(1..10)) { a -> assertSomething(a) }
    }
    "test with enums" {
        // TODO use exhaustive
        forAll(Arb.enum<MyEnum>()) { a -> assertSomething(a) }
    }
    "test with emails" {
        // TODO use localPart and domain
        forAll(Arb.email()) { a -> assertSomething(a) }
    }
    "test with dates" {
        // TODO use min and max
        forAll(Arb.localDate()) { a -> assertSomething(a) }
    }
    "test with IP addresses" {
        forAll(Arb.ipAddressV4()) { a -> assertSomething(a) }
    }
    // Extra Arbs
    "test with names" {
        // TODO use Harry Potter names
        forAll(Arb.name()) { a -> assertSomething(a) }
    }
    "test with countries" {
        forAll(Arb.country()) { a -> assertSomething(a) }
    }
    "test with ice cream flavors" {
        forAll(Arb.iceCreamFlavors()) { a -> assertSomething(a) }
    }
})

enum class MyEnum {
    VALUE_1,
    VALUE_2,
    VALUE_3,
    VALUE_4
}

private fun assertSomething(vararg value: Any?): Boolean {
    println(value.joinToString(separator = " | "))
    return true
}